#基本的には全探索すれば良い
n = int(input())
a = [list(map(int,list(input()))) for _ in range(n)] #入力注意
ans = 0
for i in range(n): #どのマスからスタートするか全探索する
  for j in range(n):
    for x in range(-1,2): #どの方向に進むか全探索する
      for y in range(-1,2):
        if x==0 and y==0: #x軸にもy軸にも進まない場合
          continue
        mx = 0 #今いる座標
        h,w = i,j
        for _ in range(n):
          mx *= 10 #高橋君が通ったマスに書かれている数字を左から通った順番に並べた整数を求めるときははじめ整数 mx=0 を持ち、マスを移動するたびに mx を 10 倍し、
          mx += a[h][w] # mx に今いるマスに書かれた整数を足す
          h += x
          h %= n #上下左右がつながっているため、循環する→modNで管理する
          w += y
          w %= n
        ans = max(ans,mx)
print(ans)

"""
modNで管理するところ

入力例1の場合
(0,2)から右下に進むと、
(1,3)
(2,0)
(3,1)
行、列ともに1ずつ増えていき、4になったら0へ戻る。
これはN=4で割った余りを使うと以下のように書ける。
((0+0)%4,(2+0)%4)→(0%4,2%4)→(0,2)
((0+1)%4,(2+1)%4)→(1%4,3%4)→(1,3)
((0+2)%4,(2+2)%4)→(2%4,4%4)→(2,0)
((0+3)%4,(2+3)%4)→(3%4,5%4)→(3,1)
つまり右下にi移動したマスというのは
((スタート行+i)%N,(スタート列+i)%N)

左上ならマイナス。
((スタート行-i)%N,(スタート列-i)%N)

右なら列だけ増える。
(スタート行,(スタート列+i)%N)
"""